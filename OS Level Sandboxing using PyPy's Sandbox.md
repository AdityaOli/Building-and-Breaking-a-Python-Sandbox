#Building and Breaking a Python Sandbox
###Building a Sandbox:
####Two main ways in python
1. Language Level Sandboxing using pysandbox
2. OS-Level Sandboxing using PyPy's Sandbox
##Let us begin by understanding some theory first, and then we would move ahead with the practical part.

####We would be covering OS(Operating System) Level Sandboxing using PyPy in this document.
### What is PyPy?
Historically, PyPy has been used to mean two things. The first is the *RPython translation toolchain 
for generating interpreters for dynamic programming languages*. And the second is *one particular 
implementation of Python produced with it*. Because RPython uses the same syntax as Python, this generated
version became known as **Python interpreter written in Python**. It is designed to be flexible and easy to 
experiment with. To make it more clear, we start with source code written in RPython, apply the RPython 
translation toolchain, and end up with PyPy as a binary executable. This executable is the Python interpreter.

###Downloading and Installing PyPy

####Using a packaged PyPy
Some Linux distributions provide a pypy package. Note that in order to install additional modules that require
compilation, you may need to install additional packages such as pypy-dev. This will manifest as an error 
about "missing Python.h". Distributions do not as of yet supply many pypy-ready packages, if you require 
additional modules it is recommended creating a virtualenv and using pip.

####Download a pre-built PyPy
The quickest way to start using PyPy is to download a prebuilt binary for your OS and architecture. You can 
either use the most recent release or one of the development nightly build. Please note that the nightly builds
are not guaranteed to be as stable as official releases, use them at your own risk.

####Installing PyPy
PyPy is ready to be executed as soon as you unpack the tarball or the zip file, with no need to install it in any specific location:
```
$ tar xf pypy-2.1.tar.bz2
$ ./pypy-2.1/bin/pypy
Python 2.7.3 (480845e6b1dd, Jul 31 2013, 11:05:31)
[PyPy 2.1.0 with GCC 4.4.3] on linux2
Type "help", "copyright", "credits" or "license" for more information.
And now for something completely different: ``PyPy is an exciting technology
that lets you to write fast, portable, multi-platform interpreters with less
effort''
>>>>
```

####Installing more modules
If you want to install 3rd party libraries, the most convenient way is to install pip
using ensurepip (unless you want to install virtualenv as explained below; then you can
directly use pip inside virtualenvs):
```
$ ./pypy-xxx/bin/pypy -m ensurepip
$ ./pypy-xxx/bin/pip install pygments  # for example
```
Third party libraries will be installed in ```pypy-xxx/site-packages```, and the scripts in ```pypy-xxx/bin```.

####Installing using virtualenv
It is often convenient to run pypy inside a virtualenv. To do this you need a recent version of 
virtualenv -- 1.6.1 or greater. You can then install PyPy both from a precompiled tarball or from a 
mercurial checkout:
```
# from a tarball
$ virtualenv -p /opt/pypy-xxx/bin/pypy my-pypy-env

# from the mercurial checkout
$ virtualenv -p /path/to/pypy/pypy/translator/goal/pypy-c my-pypy-env
```
Note that ```bin/python``` is now a symlink to ```bin/pypy```.

###PyPy’s sandboxing features
    PyPy offers sandboxing at a level similar to OS-level sandboxing (e.g. SECCOMP on Linux), but implemented
in a fully portable way. To use it, a (regular, trusted) program launches a subprocess that is a special 
sandboxed version of PyPy. This subprocess can run arbitrary untrusted Python code, but all its input/output
is serialized to a stdin/stdout pipe instead of being directly performed. The outer process reads the pipe 
and decides which commands are allowed or not (sandboxing), or even reinterprets them differently (virtualization).
A potential attacker can have arbitrary code run in the subprocess, but cannot actually do any input/output not 
controlled by the outer process. Additional barriers are put to limit the amount of RAM and CPU time used.
    Note that this is very different from sandboxing at the Python language level, i.e. placing restrictions on 
what kind of Python code the attacker is allowed to run. Another point of comparison: if we were instead to try 
to plug CPython into a special virtualizing C library, we would get a result that is not only OS-specific, but 
unsafe, because CPython can be segfaulted (in many ways, all of them really, really obscure). Given enough efforts,
an attacker can turn almost any segfault into a vulnerability. The C code generated by PyPy is not segfaultable, as
long as our code generators are correct - that’s a lower number of lines of code to trust. For the paranoid, PyPy 
translated with sandboxing also contains systematic run-time checks (against buffer overflows for example) that are
normally only present in debugging versions.

####Understanding how PyPy does it:
    One of PyPy’s translation aspects is a sandboxing feature. It’s “sandboxing” as in “full virtualization”, but done 
in normal C with no OS support at all. It’s a two-processes model: we can translate PyPy to a special “pypy-c-sandbox”
executable, which is safe in the sense that it doesn’t do any library or system calls - instead, whenever it would like
to perform such an operation, it marshals the operation name and the arguments to its stdout and it waits for the
marshalled result on its stdin. This pypy-c-sandbox process is meant to be run by an outer “controller” program that 
answers these operation requests.
    The pypy-c-sandbox program is obtained by adding a transformation during translation, which turns all RPython-level
external function calls into stubs that do the marshalling/waiting/unmarshalling. ***An attacker that tries to escape
the sandbox is stuck within a C program that contains no external function calls at all except for writing to stdout
and reading from stdin***. (It’s still attackable in theory, e.g. by exploiting segfault-like situations, but as 
explained in the introduction we think that PyPy is rather safe against such attacks.)
    The outer controller is a plain Python program that can run in CPython or a regular PyPy. It can perform any 
virtualization it likes, by giving the subprocess any custom view on its world. For example, while the subprocess
thinks it’s using file handles, in reality the numbers are created by the controller process and so they need not be
(and probably should not be) real OS-level file handles at all. In the demo controller that has been implemented there is 
simply a mapping from numbers to file-like objects. The controller answers to the “os_open” operation by translating
the requested path to some file or file-like object in some virtual and completely custom directory hierarchy. The
file-like object is put in the mapping with any unused number >= 3 as a key, and the latter is returned to the subprocess.
The “os_read” operation works by mapping the pseudo file handle given by the subprocess back to a file-like object in
the controller, and reading from the file-like object.
    Translating an RPython program with sandboxing enabled also uses a special flag that enables all sorts of C-level 
assertions against index-out-of-bounds accesses.By the way, as you should have realized, it’s really independent from
the fact that it’s PyPy that we are translating. Any RPython program should do. The controller is only called 
“pypy_interact” because it emulates a file hierarchy that makes pypy-c-sandbox happy - it contains (read-only) 
virtual directories like /bin/lib/pypy1.2/lib-python and /bin/lib/pypy1.2/lib_pypy and it pretends that the 
executable is /bin/pypy-c.


####How to use?
Grab a copy of the pypy repository. In the directory pypy/goal, run:
```
../../rpython/bin/rpython -O2 --sandbox targetpypystandalone.py
```
If you don’t have a regular PyPy installed, you should, because it’s faster to translate; but you can also 
run the same line with python in front.

To run it, use the tools in the pypy/sandbox directory:
```
./pypy_interact.py /some/path/pypy-c-sandbox [args...]
Just like with pypy-c, if you pass no argument you get the interactive prompt. In theory it’s impossible to do anything bad or read a random file on the machine from this prompt. To pass a script as an argument you need to put it in a directory along with all its dependencies, and ask pypy_interact to export this directory (read-only) to the subprocess’ virtual /tmp directory with the --tmp=DIR option. Example:

mkdir myexported
cp script.py myexported/
./pypy_interact.py --tmp=myexported /some/path/pypy-c-sandbox /tmp/script.py
This is safe to do even if script.py comes from some random untrusted source, e.g. if it is done by an HTTP server.
```
To limit the used heapsize, use the ```--heapsize=N``` option to pypy_interact.py. You can also give a limit to the CPU time (real time) by using the ```--timeout=N``` option.
Not all operations are supported; e.g. if you type os.readlink(‘...’), the controller crashes with an exception 
and the subprocess is killed. Other operations make the subprocess die directly with a “Fatal RPython error”. None of this is a security hole. More
importantly, most other built-in modules are not enabled. 
